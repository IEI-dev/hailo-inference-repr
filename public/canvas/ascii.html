<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Graph to ASCII</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <pre></pre>
    <div>
        <button class="big"">
          <a href="./canvas.html">BACK</a>
        </button>
      </div>
    <script>
      let source =
        "https://i.scdn.co/image/ab6761610000e5ebe839c2f7426d6dddc154c2ea";
      window.onload = function() {
        setTimeout(redrawAsASCII(source), 500);
      };
      // 取得圖像載入promise
      function loadImage(src) {
        let img = new Image();
        // 把resolve暴露給外部變數
        let resolve;
        let loadPromise = new Promise((res) => {
          resolve = res;
        });
        // 這一步cross-origin是因為我們的圖片是外部來源
        // 如果沒有把外部來源設置為"Anonymous",drawImage方法會排除掉非本地來源的圖片資訊, 導致無法進行下一步繪圖
        img.crossOrigin = "Anonymous";
        img.onload = () => {
          resolve(img);
        };
        img.src = src;

        return loadPromise;
      }

      async function getImageDataFromImage(src, ratio = 0.1) {
        // 這邊有一個ratio參數是因為我讀取的圖片稍微有點大張
        // 所以我補一個參數讓我可以自己決定要把圖片縮小多少倍率
        const img = await loadImage(src);
        const width = img.width * ratio;
        const height = img.height * ratio;
        // 把外部圖源繪製到架空的canvas上面然後取得imageData
        const cvs = document.createElement("canvas");
        const ctx = cvs.getContext("2d");
        cvs.width = width;
        cvs.height = height;
        ctx.drawImage(img, 0, 0, width, height);
        const imageData = ctx.getImageData(0, 0, width, height);
        return imageData;
      }

      async function turnImageDataIntoGrayscale(src) {
        const imageData = await getImageDataFromImage(src);
        const data = imageData.data;
        // 這邊這個loop的用意就在於把channel值依像素順序來執行程序
        for (let i = 0; i < data.length; i = i + 4) {
          const r = data[i];
          const g = data[i + 1];
          const b = data[i + 2];
          //取得rgb值得平均, 如此一來因為rgb都變成同一個數值
          // 圖像就會變成灰階圖
          const average = (r + g + b) / 3;
          data[i] = data[i + 1] = data[i + 2] = average;
        }
        return imageData;
      }

      async function redrawAsASCII(src) {
        const grayscaleImageData = await turnImageDataIntoGrayscale(src);
        // 取用的樣版字元
        const glyphSource = "＄＠＃＊。";
        let stringOutput = "";
        for (let i = 0; i < grayscaleImageData.data.length; i = i + 4) {
          const pixelIndex = Math.ceil(i / 4);
          // 從像素的次序來判斷該像素是否為右邊緣像素
          const pixelIsRightRimPixel =
            (pixelIndex + 1) % grayscaleImageData.width === 0;
          // 根據像素的灰階值, 用內插的方式來決定要使用哪一個樣版字元來代表該像素
          const glyphIndex = Math.floor(
            (grayscaleImageData.data[i] / 255) * (glyphSource.length - 1)
          );

          stringOutput += glyphSource[glyphIndex];

          if (pixelIsRightRimPixel) {
            // 如果是最右邊緣像素, 則另外補一個換行符號
            stringOutput += "\n";
          }
        }
        // 把字串填入pre tag
        const text = document.querySelector("pre");
        text.innerHTML = stringOutput;
      }
    </script>
  </body>
</html>
